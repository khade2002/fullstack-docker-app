// regjsparser
//
// ==================================================================
//
// See ECMA-262 Standard: 15.10.1
//
// NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
//   term "Anchor" is used.
//
// Pattern ::
//      Disjunction
//
// Disjunction ::
//      Alternative
//      Alternative | Disjunction
//
// Alternative ::
//      [empty]
//      Alternative Term
//
// Term ::
//      Anchor
//      Anchor Quantifier (see https://github.com/jviereck/regjsparser/issues/130)
//      Atom
//      Atom Quantifier
//
// Anchor ::
//      ^
//      $
//      \ b
//      \ B
//      ( ? = Disjunction )
//      ( ? ! Disjunction )
//      ( ? < = Disjunction )
//      ( ? < ! Disjunction )
//
// Quantifier ::
//      QuantifierPrefix
//      QuantifierPrefix ?
//
// QuantifierPrefix ::
//      *
//      +
//      ?
//      { DecimalDigits }
//      { DecimalDigits , }
//      { DecimalDigits , DecimalDigits }
//
// Atom ::
//      PatternCharacter
//      .
//      \ AtomEscape
//      CharacterClass
//      ( GroupSpecifier Disjunction )
//      ( ? : Disjunction )
//
// PatternCharacter ::
//      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
//
// AtomEscape ::
//      DecimalEscape
//      CharacterClassEscape
//      CharacterEscape
//      k GroupName
//
// CharacterEscape[U] ::
//      ControlEscape
//      c ControlLetter
//      HexEscapeSequence
//      RegExpUnicodeEscapeSequence[?U] (ES6)
//      IdentityEscape[?U]
//
// ControlEscape ::
//      one of f n r t v
// ControlLetter ::
//      one of
//          a b c d e f g h i j k l m n o p q r s t u v w x y z
//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
//
// IdentityEscape ::
//      SourceCharacter but not c
//
// DecimalEscape ::
//      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
//
// CharacterClassEscape ::
//      one of d D s S w W
//
// CharacterClass ::
//      [ [lookahead ∉ {^}] ClassContents ]
//      [ ^ ClassContents ]
//
// ClassContents ::
//      [empty]
//      [~V] NonemptyClassRanges
//      [+V] ClassSetExpression
//
// NonemptyClassRanges ::
//      ClassAtom
//      ClassAtom NonemptyClassRangesNoDash
//      ClassAtom - ClassAtom ClassContents
//
// NonemptyClassRangesNoDash ::
//      ClassAtom
//      ClassAtomNoDash NonemptyClassRangesNoDash
//      ClassAtomNoDash - ClassAtom ClassContents
//
// ClassAtom ::
//      -
//      ClassAtomNoDash
//
// ClassAtomNoDash ::
//      SourceCharacter but not one of \ or ] or -
//      \ ClassEscape
//
// ClassEscape ::
//      DecimalEscape
//      b
//      CharacterEscape
//      CharacterClassEscape
//
// GroupSpecifier ::
//      [empty]
//      ? GroupName
//
// GroupName ::
//      < RegExpIdentifierName >
//
// RegExpIdentifierName ::
//      RegExpIdentifierStart
//      RegExpIdentifierName RegExpIdentifierContinue
//
// RegExpIdentifierStart ::
//      UnicodeIDStart
//      $
//      _
//      \ RegExpUnicodeEscapeSequence
//
// RegExpIdentifierContinue ::
//      UnicodeIDContinue
//      $
//      _
//      \ RegExpUnicodeEscapeSequence
//      <ZWNJ>
//      <ZWJ>
//
// --------------------------------------------------------------
// NOTE: The following productions refer to the "set notation and
//       properties of strings" proposal.
//       https://github.com/tc39/proposal-regexp-set-notation
// --------------------------------------------------------------
//
// ClassSetExpression ::
//      ClassUnion
//      ClassIntersection
//      ClassSubtraction
//
// ClassUnion ::
//      ClassSetRange ClassUnion?
//      ClassSetOperand ClassUnion?
//
// ClassIntersection ::
//      ClassSetOperand && [lookahead ≠ &] ClassSetOperand
//      ClassIntersection && [lookahead ≠ &] ClassSetOperand
//
// ClassSubtraction ::
//      ClassSetOperand -- ClassSetOperand
//      ClassSubtraction -- ClassSetOperand
//
// ClassSetRange ::
//      ClassSetCharacter - ClassSetCharacter
//
// ClassSetOperand ::
//      ClassSetCharacter
//      ClassStringDisjunction
//      NestedClass
//
// NestedClass ::
//      [ [lookahead ≠ ^] ClassContents[+U,+V] ]
//      [ ^ ClassContents[+U,+V] ]
//      \ CharacterClassEscape[+U, +V]
//
// ClassStringDisjunction ::
//      \q{ ClassStringDisjunctionContents }
// 
// ClassStringDisjunctionContents ::
//      ClassString
//      ClassString | ClassStringDisjunctionContents
//
// ClassString ::
//      [empty]
//      NonEmptyClassString
//
// NonEmptyClassString ::
//      ClassSetCharacter NonEmptyClassString?
//
// ClassSetCharacter ::
//      [lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
//      \ CharacterEscape[+U]
//      \ ClassSetReservedPunctuator
//      \b
//
// ClassSetReservedDoublePunctuator ::
//      one of && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~
//
// ClassSetSyntaxCharacter ::
//      one of ( ) [ ] { } / - \ |
//
// ClassSetReservedPunctuator ::
//      one of & - ! # % , : ; < = > @ ` ~
//
// --------------------------------------------------------------
// NOTE: The following productions refer to the
//       "Regular Expression Pattern Modifiers for ECMAScript" proposal.
//       https://github.com/tc39/proposal-regexp-modifiers
// --------------------------------------------------------------
//
// Atom ::
//      ( ? RegularExpressionModifiers : Disjunction )
//      ( ? RegularExpressionModifiers - RegularExpressionModifiers : Disjunction )
//
// RegularExpressionModifiers:
//      [empty]
//      RegularExpressionModifiers RegularExpressionModifier
//
// RegularExpressionModifier:
//      one of i m s

"use strict";
(function() {

  var fromCodePoint = String.fromCodePoint || (function() {
    // Implementation taken from
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint

    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;

    return function fromCodePoint() {
      var MAX_SIZE = 0x4000;
      var codeUnits = [];
      var highSurrogate;
      var lowSurrogate;
      var index = -1;
      var length = arguments.length;
      if (!length) {
        return '';
      }
      var result = '';
      while (++index < length) {
        var codePoint = Number(arguments[index]);
        if (
          !isFinite(codePoint) ||       // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 ||              // not a valid Unicode code point
          codePoint > 0x10FFFF ||       // not a valid Unicode code point
          floor(codePoint) != codePoint // not an integer
        ) {
          throw RangeError('Invalid code point: ' + codePoint);
        }
        if (codePoint <= 0xFFFF) { // BMP code point
          codeUnits.push(codePoint);
        } else { // Astral code point; split in surrogate halves
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = (codePoint % 0x400) + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 == length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
  }());

  function parse(str, flags, features) {
    if (!features) {
      features = {};
    }

    function updateRawStart(node, start) {
      node.range[0] = start;
      node.raw = str.substring(start, node.range[1]);
      return node;
    }

    function createAnchor(kind, rawLength) {
      return {
        type: 'anchor',
        kind: kind,
        range: [
          pos - rawLength,
          pos
        ],
        raw: str.substring(pos - rawLength, pos)
      };
    }

    function createValue(kind, codePoint, from, to) {
      return {
        type: 'value',
        kind: kind,
        codePoint: codePoint,
        range: [from, to],
        raw: str.substring(from, to)
      };
    }

    function createEscaped(kind, codePoint, value, fromOffset) {
      fromOffset = fromOffset || 0;
      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
    }

    function createCharacter(matches) {
      var _char = matches[0];
      var first = _char.charCodeAt(0);
      if (isUnicodeMode) {
        var second;
        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
          second = lookahead().charCodeAt(0);
          if (second >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            pos++;
            return createValue(
              'symbol',
              (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,
              pos - 2, pos);
          }
        }
      }
      return createValue('symbol', first, pos - 1, pos);
    }

    function createDisjunction(alternatives, from, to) {
      return {
        type: 'disjunction',
        body: alternatives,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createDot() {
      return {
        type: 'dot',
        range: [
          pos - 1,
          pos
        ],
        raw: '.'
      };
    }

    function createCharacterClassEscape(value) {
      return {
        type: 'characterClassEscape',
        value: value,
        range: [
          pos - 2,
          pos
        ],
        raw: str.substring(pos - 2, pos)
      };
    }

    function createReference(matchIndex) {
      var start = pos - 1 - matchIndex.length;
      return {
        type: 'reference',
        matchIndex: parseInt(matchIndex, 10),
        range: [
          start,
          pos
        ],
        raw: str.substring(start, pos)
      };
    }

    function createNamedReference(name) {
      var start = name.range[0] - 3;
      return {
        type: 'reference',
        name: name,
        range: [
          start,
          pos
        ],
        raw: str.substring(start, pos)
      };
    }

    function createGroup(behavior, disjunction, from, to) {
      return {
        type: 'group',
        behavior: behavior,
        body: disjunction,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createQuantifier(min, max, from, to, symbol) {
      if (to == null) {
        from = pos - 1;
        to = pos;
      }

      return {
        type: 'quantifier',
        min: min,
        max: max,
        greedy: true,
        body: null, // set later on
        symbol: symbol,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createAlternative(terms, from, to) {
      return {
        type: 'alternative',
        body: terms,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createCharacterClass(contents, negative, from, to) {
      return {
        type: 'characterClass',
        kind: contents.kind,
        body: contents.body,
        negative: negative,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createClassRange(min, max, from, to) {
      // See 15.10.2.15:
      if (min.codePoint > max.codePoint) {
        bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
      }

      return {
        type: 'characterClassRange',
        min: min,
        max: max,
        range: [
          from,
          to
        ],
        raw: str.substring(from, to)
      };
    }

    function createClassStrings(strings, from, to) {
      return {
        type: 'classStrings',
        strings: strings,
        range: [from, to],
        raw: str.substring(from, to)
      };
    }

    function createClassString(characters, from, to) {
      return {
        type: 'classString',
        characters: characters,
        range: [from, to],
        raw: str.substring(from, to)
      };
    }

    function flattenBody(body) {
      if (body.type === 'alternative') {
        return body.body;
      } else {
        return [body];
      }
    }

    function incr(amount) {
      amount = (amount || 1);
      pos += amount;
    }

    function consume(amount) {
      var res = str.substring(pos, pos += amount);
      return res;
    }

    function skip(value) {
      if (!match(value)) {
        bail('character', value);
      }
    }

    function match(value) {
      var len = value.length;
      if (str.substring(pos, pos + len) === value) {
        incr(len);
        return value;
      }
    }

    function matchOne(value) {
      if (str[pos] === value) {
        pos++;
        return value;
      }
    }

    function lookahead() {
      return str[pos];
    }

    function currentOne(value) {
      return str[pos] === value;
    }

    function current(value) {
      var len = value.length;
      return str.substring(pos, pos + len) === value;
    }

    function next(value) {
      return str[pos + 1] === value;
    }

    function matchReg(regExp) {
      var subStr = str.substring(pos);
      var res = subStr.match(regExp);
      if (res) {
        pos += res[0].length;
      }
      return res;
    }

    function parseDisjunction() {
      // Disjunction ::
      //      Alternative
      //      Alternative | Disjunction
      var res = [], from = pos;
      res.push(parseAlternative());

      while (matchOne('|')) {
        res.push(parseAlternative());
      }

      if (res.length === 1) {
        return res[0];
      }

      return createDisjunction(res, from, pos);
    }

    function parseAlternative() {
      var res = [], from = pos;
      var term;

      // Alternative ::
      //      [empty]
      //      Alternative Term
      while (term = parseTerm()) {
        res.push(term);
      }

      if (res.length === 1) {
        return res[0];
      }

      return createAlternative(res, from, pos);
    }

    function parseTerm() {
      // Term ::
      //      Anchor
      //      Atom
      //      Atom Quantifier

      // Term (Annex B)::
      //      [~UnicodeMode] QuantifiableAssertion Quantifier (see https://github.com/jviereck/regjsparser/issues/130)
      //      [~UnicodeMode] ExtendedAtom Quantifier

      // QuantifiableAssertion::
      //      (?= Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] )
      //      (?! Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] ) 

      if (pos >= str.length || currentOne('|') || currentOne(')')) {
        return null; /* Means: The term is empty */
      }

      var anchor = parseAnchor();
      var quantifier;
      if (anchor) {
        var pos_backup = pos;
        quantifier = parseQuantifier() || false;
        if (quantifier) {
          // Annex B
          if (!isUnicodeMode && anchor.type === "group") {
            quantifier.body = flattenBody(anchor);
            // The quantifier contains the anchor. Therefore, the beginning of the
            // quantifier range is given by the beginning of the anchor.
            updateRawStart(quantifier, anchor.range[0]);
            return quantifier;
          }
          pos = pos_backup;
          bail("Expected atom");
        }
        return anchor;
      }

      // If there is no Anchor, try to parse an atom.
      var atom = parseAtomAndExtendedAtom();
      if (!atom) {
        // Check if a quantifier is following. A quantifier without an atom
        // is an error.
        pos_backup = pos;
        quantifier = parseQuantifier() || false;
        if (quantifier) {
          pos = pos_backup;
          bail("Expected atom");
        }

        // If no unicode flag, then try to parse ExtendedAtom -> ExtendedPatternCharacter.
        //      ExtendedPatternCharacter
        if (!isUnicodeMode && matchOne("{")) {
          atom = createCharacter("{");
        } else {
          bail("Expected atom");
        }
      }

      quantifier = parseQuantifier() || false;
      if (quantifier) {
        var type = atom.type, behavior = atom.behavior;
        if (
          type === "group" &&
          (behavior === "negativeLookbehind" ||
            behavior === "lookbehind")
        ) {
          bail(
            "Invalid quantifier",
            "",
            quantifier.range[0],
            quantifier.range[1]
          );
        }
        quantifier.body = flattenBody(atom);
        // The quantifier contains the atom. Therefore, the beginning of the
        // quantifier range is given by the beginning of the atom.
        updateRawStart(quantifier, atom.range[0]);
        return quantifier;
      }
      return atom;
    }

    function parseGroup(matchA, typeA, matchB, typeB) {
      var type = null, from = pos;

      if (match(matchA)) {
        type = typeA;
      } else if (match(matchB)) {
        type = typeB;
      } else {
        return false;
      }

      return finishGroup(type, from);
    }

    function finishGroup(type, from) {
      var body = parseDisjunction();
      if (!body) {
        bail('Expected disjunction');
      }
      skip(')');
      var group = createGroup(type, flattenBody(body), from, pos);

      if (type == 'normal') {
        // Keep track of the number of closed groups. This is required for
        // parseDecimalEscape(). In case the string is parsed a second time the
        // value already holds the total count and no incrementation is required.
        if (firstIteration) {
          closedCaptureCounter++;
        }
      }
      return group;
    }

    function parseAnchor() {
      // Anchor ::
      //      ^
      //      $
      //      \ b
      //      \ B
      //      ( ? = Disjunction )
      //      ( ? ! Disjunction )

      switch(lookahead()) {
        case '^':
          incr();
          return createAnchor('start', 1 /* rawLength */);
        case '$':
          incr();
          return createAnchor('end', 1 /* rawLength */);
        case '\\': {
          if (next('b')) {
            incr(2);
            return createAnchor('boundary', 2 /* rawLength */);
          } else if (next('B')) {
            incr(2);
            return createAnchor('not-boundary', 2 /* rawLength */);
          }
          break;
        }
        case '(':
          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
        default:
          return;
      }
    }

    function parseQuantifier() {
      // Quantifier ::
      //      QuantifierPrefix
      //      QuantifierPrefix ?
      //
      // QuantifierPrefix ::
      //      *
      //      +
      //      ?
      //      { DecimalDigits }
      //      { DecimalDigits , }
      //      { DecimalDigits , DecimalDigits }

      var res, from = pos;
      var quantifier;
      var min, max;

      switch(lookahead()) {
        case '*':
          incr();
          quantifier = createQuantifier(0, undefined, undefined, undefined, '*');
          break;
        case '+':
          incr();
          quantifier = createQuantifier(1, undefined, undefined, undefined, "+");
          break;
        case '?':
          incr();
          quantifier = createQuantifier(0, 1, undefined, undefined, "?");
          break;
        case '{': {
          if (res = matchReg(/^\{(\d+)\}/)) {
            min = parseInt(res[1], 10);
            quantifier = createQuantifier(min, min, from, pos);
          }
          else if (res = matchReg(/^\{(\d+),\}/)) {
            min = parseInt(res[1], 10);
            quantifier = createQuantifier(min, undefined, from, pos);
          }
          else if (res = matchReg(/^\{(\d+),(\d+)\}/)) {
            min = parseInt(res[1], 10);
            max = parseInt(res[2], 10);
            if (min > max) {
              bail('numbers out of order in {} quantifier', '', from, pos);
            }
            quantifier = createQuantifier(min, max, from, pos);
          }
    
          if (min && (!Number.isSafeInteger(min)) || (max && !Number.isSafeInteger(max))) {
            bail("iterations outside JS safe integer range in quantifier", "", from, pos);
          }
        }
      } 

      if (quantifier) {
        if (matchOne('?')) {
          quantifier.greedy = false;
          quantifier.range[1] += 1;
        }
      }

      return quantifier;
    }

    function parseAtomAndExtendedAtom() {
      // Parsing Atom and ExtendedAtom together due to redundancy.
      // ExtendedAtom is defined in Apendix B of the ECMA-262 standard.
      //
      // SEE: https://www.ecma-international.org/ecma-262/10.0/index.html#prod-annexB-ExtendedPatternCharacter
      //
      // Atom ::
      //      PatternCharacter
      //      .
      //      \ AtomEscape
      //      CharacterClass
      //      ( GroupSpecifier Disjunction )
      //      ( ? RegularExpressionModifiers : Disjunction )
      //      ( ? RegularExpressionModifiers - RegularExpressionModifiers : Disjunction )
      // ExtendedAtom ::
      //      ExtendedPatternCharacter
      // ExtendedPatternCharacter ::
      //      SourceCharacter but not one of ^$\.*+?()[|

      var res;

      switch (res = lookahead()) {
        case '.':
          //      .
          incr();
          return createDot();
        case '\\': {
          //      \ AtomEscape
          incr();
          res = parseAtomEscape();
          if (!res) {
            if (!isUnicodeMode && lookahead() == 'c') {
              // B.1.4 ExtendedAtom
              // \[lookahead = c]
              return createValue('symbol', 92, pos - 1, pos);
            }
            bail('atomEscape');
          }
          return res;
        }
        case '[':
          return parseCharacterClass();
        case '(': {
          if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
            return res;
          }
          else if (features.namedGroups && match("(?<")) {
            var name = parseIdentifier();
            skip(">");
            var group = finishGroup("normal", name.range[0] - 3);
            group.name = name;
            return group;
          }
          else if (features.modifiers && current("(?") && str[pos + 2] != ":") {
            return parseModifiersGroup();
          }
          else {
            //      ( Disjunction )
            //      ( ? : Disjunction )
            return parseGroup('(?:', 'ignore', '(', 'normal');
          }
        }
        case ']':
        case '}':
          //      ExtendedPatternCharacter, first part. See parseTerm.
          if (!isUnicodeMode) {
            incr();
            return createCharacter(res);
          }
          break;
        case '^':
        case '$':
        case '*':
        case '+':
        case '?':
        case '{':
        case ')':
        case '|':
          break;
        default:
          //      PatternCharacter
          incr();
          return createCharacter(res);
      }
    }

    function parseModifiersGroup() {
      function hasDupChar(str) {
        var i = 0;
        while (i < str.length) {
          if (str.indexOf(str[i], i + 1) != -1) {
            return true;
          }
          i++;
        }
        return false;
      }

      var from = pos;
      incr(2);

      var enablingFlags = matchReg(/^[sim]+/);
      var disablingFlags;
      if(matchOne("-") && lookahead() !== ":"){
        disablingFlags = matchReg(/^[sim]+/);
        if (!disablingFlags) {
          bail('Invalid flags for modifiers group');
        }
      } else if(!enablingFlags){
        bail('Invalid flags for modifiers group');
      }

      enablingFlags = enablingFlags ? enablingFlags[0] : "";
      disablingFlags = disablingFlags ? disablingFlags[0] : "";

      var flags = enablingFlags + disablingFlags;
      if(flags.length > 3 || hasDupChar(flags)) {
        bail('flags cannot be duplicated for modifiers group');
      }

      if(!matchOne(":")) {
        bail('Invalid flags for modifiers group');
      }

      var modifiersGroup = finishGroup("ignore", from);

      modifiersGroup.modifierFlags = {
        enabling: enablingFlags,
        disabling: disablingFlags
      };

      return modifiersGroup;
    }

    function parseUnicodeSurrogatePairEscape(firstEscape, isUnicodeMode) {
      if (isUnicodeMode) {
        var first, second;
        if (firstEscape.kind == 'unicodeEscape' &&
          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&
          currentOne('\\') && next('u') ) {
          var prevPos = pos;
          pos++;
          var secondEscape = parseClassEscape();
          if (secondEscape.kind == 'unicodeEscape' &&
            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            firstEscape.kind = 'unicodeCodePointEscape';
            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            firstEscape.range[1] = pos;
            firstEscape.raw = str.substring(firstEscape.range[0], pos)
          }
          else {
            pos = prevPos;
          }
        }
      }
      return firstEscape;
    }

    function parseClassEscape() {
      return parseAtomEscape(true);
    }

    function parseAtomEscape(insideCharacterClass) {
      // AtomEscape ::
      //      DecimalEscape
      //      CharacterEscape
      //      CharacterClassEscape
      //      k GroupName

      var res, from = pos, ch;

      switch (ch = lookahead()) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          return parseDecimalEscape(insideCharacterClass);
        case 'B': {
          if (insideCharacterClass) {
            bail('\\B not possible inside of CharacterClass', '', from);
            break;
          } else {
            return parseIdentityEscape();
          }
        }
        case 'b': {
          if (insideCharacterClass) {
            // 15.10.2.19
            // The production ClassEscape :: b evaluates by returning the
            // CharSet containing the one character <BS> (Unicode value 0008).
            incr();
            return createEscaped('singleEscape', 0x0008, '\\b');
          } else {
            return parseIdentityEscape();
          }
        }
        case 'c': {
          if (insideCharacterClass) {
            if (!isUnicodeMode && (res = matchReg(/^c(\d)/))) {
              // B.1.4
              // c ClassControlLetter, ClassControlLetter = DecimalDigit
              return createEscaped('controlLetter', res[1] + 16, res[1], 2);
            } else if (!isUnicodeMode && match("c_")) {
              // B.1.4
              // c ClassControlLetter, ClassControlLetter = _
              return createEscaped('controlLetter', 31, '_', 2);
            }
          }
          return parseCharacterEscape();
        }
        // CharacterClassEscape :: one of d D s S w W
        case 'd':
        case 'D':
        case 'w':
        case 'W':
        case 's':
        case 'S':
          incr();
          return createCharacterClassEscape(ch);
        case 'k':
          return parseNamedReference() || parseIdentityEscape();
        case 'p':
        case 'P':
          return parseUnicodePropertyEscape() || parseIdentityEscape();
        case '-': {
          //     [+U] -
          if (insideCharacterClass && isUnicodeMode) {
            incr();
            return createEscaped('singleEscape', 0x002d, '\\-